# SPDX-License-Identifier: LGPL-2.1-only
#

from collections.abc import Callable, Iterable, Iterator
from dataclasses import dataclass
from typing import Any, NoReturn

import enum
import ipaddress
import setools.exception
import weakref

AnyConstraint = "Constraint" | "Validatetrans"
AnyDefault = "Default" | "DefaultRange"
AnyRBACRule = "RoleAllow" | "RoleTransition"
AnyTERule = "AVRule" | "AVRuleXperm" | "TERule" | "FileNameTERule"
TypeOrAttr = "Type" | "TypeAttribute"

def lookup_boolean_name_sub(name: str) -> str: ...

#
# Policy-wide generic classes, in inheritance order
#

class PolicyObject:
    policy: "SELinuxPolicy" = ...
    def statement(self) -> str: ...
    def __copy__(self) -> "PolicyObject": ...
    def __deepcopy__(self, memo) -> "PolicyObject": ...
    def __eq__(self, other) -> bool: ...
    def __ge__(self, other) -> bool: ...
    def __gt__(self, other) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other) -> bool: ...
    def __lt__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...

class PolicyRule(PolicyObject):
    conditional: "Conditional" = ...
    conditional_block: bool = ...
    extended: bool = ...
    origin: "PolicyRule" = ...
    ruletype: "PolicyEnum" = ...
    source: "PolicySymbol" = ...
    target: "PolicySymbol" = ...
    tclass: "ObjClass" = ...
    xperm_type: str = ...
    perms: frozenset[str] | "IoctlSet" = ...
    default: PolicyObject = ...
    filename: str = ...
    def enabled(self, **kwargs) -> bool: ...
    def expand(self) -> Iterable["PolicyRule"]: ...

class PolicySymbol(PolicyObject):
    name: str = ...
    def __contains__(self, other) -> bool: ...
    def expand(self) -> Iterable["PolicySymbol"]: ...

class PolicyIterator:
    def reset(self) -> None: ...
    def __len__(self) -> int: ...
    def __next__(self) -> "PolicyObject" | str: ...  # str for perm vectors

class PolicyEnum(enum.Enum):
    @classmethod
    def lookup(cls, value) -> Any: ...

#
# Base classes, in alphabetical order
#

class BaseConstraint(PolicyObject):
    expression: "ConstraintExpression" = ...
    perms: frozenset[str] = ...
    ruletype: "ConstraintRuletype" = ...
    tclass: "ObjClass" = ...

class BaseMLSLevel(PolicyObject):
    sensitivity: "Sensitivity" = ...
    def categories(self) -> Iterable[Category]: ...

class BaseTERule(PolicyRule):
    conditional: "Conditional" = ...
    conditional_block: bool = ...
    filename: str = ...
    ruletype: "TERuletype" = ...
    source: TypeOrAttr = ...
    tclass: "ObjClass" = ...
    target: TypeOrAttr = ...
    def enabled(self, **kwargs) -> bool: ...

class BaseType(PolicySymbol):
    def aliases(self) -> Iterable[str]: ...
    def attributes(self) -> Iterable["BaseType"]: ...
    def expand(self) -> Iterable["BaseType"]: ...

class EbitmapIterator(PolicyIterator): ...

class HashtabIterator(PolicyIterator): ...

class Ocontext(PolicyObject):
    context: "Context" = ...

class OcontextIterator(PolicyIterator):
    def __next__(self) -> "Ocontext": ...

#
# Concrete classes, in alphabetical order
#
class AVRule(BaseTERule):
    default: NoReturn = ...
    perms: frozenset[str] = ...
    def derive_expanded(self, *args, **kwargs) -> "AVRule": ...
    def expand(self, *args, **kwargs) -> Iterable["AVRule"]: ...

class AVRuleXperm(BaseTERule):
    default: NoReturn = ...
    perms: "IoctlSet" = ...
    xperm_type: str = ...
    def expand(self, *args, **kwargs) -> Iterable["AVRuleXperm"]: ...

class Boolean(PolicySymbol):
    state: bool = ...

class BooleanHashtabIterator(HashtabIterator):
    def __next__(self) -> Boolean: ...

class Bounds(PolicyObject):
    child: "Type" = ...
    parent: "Type" = ...
    ruletype: "BoundsRuletype" = ...

class BoundsRuletype(PolicyEnum):
    typebounds: int = ...

class Category(PolicySymbol):
    def aliases(self, *args, **kwargs) -> Iterable[str]: ...

class CategoryEbitmapIterator(EbitmapIterator):
    def __next__(self) -> Category: ...

class CategoryHashtabIterator(HashtabIterator):
    def __next__(self) -> Category: ...

class Common(PolicySymbol):
    perms: frozenset[str] = ...

class CommonHashtabIterator(HashtabIterator):
    def __next__(self) -> Common: ...

class Conditional(PolicyObject):
    booleans: frozenset[Boolean] = ...
    def evaluate(self, **kwargs) -> bool: ...
    def expression(self) -> Iterable["ConditionalOperator" | str]: ...
    def false_rules(self, *args, **kwargs) -> Iterable[AnyTERule]: ...
    def true_rules(self, *args, **kwargs) -> Iterable[AnyTERule]: ...
    def truth_table(self) -> list["TruthTableRow"]: ...
    def __contains__(self, other) -> bool: ...

class ConditionalExprIterator(PolicyIterator):
    def __next__(self) -> ConditionalOperator | Boolean: ...

class ConditionalIterator(PolicyIterator):
    def __next__(self) -> Conditional: ...

class ConditionalOperator(PolicyObject):
    evaluate: Callable = ...
    precedence: int = ...
    unary: bool = ...

class ConditionalTERuleIterator(PolicyIterator):
    def ruletype_count(self, *args, **kwargs) -> Any: ...
    def __next__(self) -> AnyTERule: ...

class Constraint(BaseConstraint):
    perms: frozenset[str] = ...

class ConstraintExprIterator(PolicyIterator):
    def __next__(self) -> "ConstraintExprNode": ...

class ConstraintExprNode(PolicyObject):
    names: frozenset[TypeOrAttr] | frozenset["Role"] | frozenset["User"] = ...
    symbol_type: int = ...
    def __contains__(self, other) -> bool: ...
    def __getitem__(self, index) -> frozenset[TypeOrAttr] | frozenset["Role"] | frozenset["User"] | str: ...
    def __iter__(self) -> Iterable[frozenset[TypeOrAttr] | frozenset["Role"] | frozenset["User"] | str]: ...
    def __len__(self) -> int: ...

class ConstraintExpression(PolicyObject):
    mls: bool = ...
    roles: frozenset["Role"] = ...
    types: frozenset["Type"] = ...
    users: frozenset["User"] = ...
    def infix(self, *args, **kwargs) -> frozenset[TypeOrAttr] | frozenset["Role"] | frozenset["User"] | str: ...
    def __getitem__(self, index) -> frozenset[TypeOrAttr] | frozenset["Role"] | frozenset["User"] | str: ...
    def __iter__(self) -> Iterator[frozenset["Role"] | frozenset["Type"] | frozenset["User"] | str]: ...

class ConstraintIterator(PolicyIterator):
    def __next__(self) -> Constraint: ...

class ConstraintRuletype(PolicyEnum):
    constrain: int = ...
    mlsconstrain: int = ...
    mlsvalidatetrans: int = ...
    validatetrans: int = ...

class ConstraintUseError(setools.exception.SymbolUseError): ...

class Context(PolicyObject):
    range_: "Range" = ...
    role: "Role" = ...
    type_: "Type" = ...
    user: "User" = ...

class Default(PolicyObject):
    default: "DefaultValue" = ...
    ruletype: "DefaultRuletype" = ...
    tclass: "ObjClass" = ...

class DefaultRange(Default):
    default_range: "DefaultRangeValue" = ...

class DefaultRangeValue(PolicyEnum):
    high: int = ...
    low: int = ...
    low_high: int = ...
    @classmethod
    def from_default_range(cls, range: int | None) -> "DefaultRangeValue" | None: ...

class DefaultRuletype(PolicyEnum):
    default_range: int = ...
    default_role: int = ...
    default_type: int = ...
    default_user: int = ...

class DefaultValue(PolicyEnum):
    glblub: int = ...
    source: int = ...
    target: int = ...
    @classmethod
    def from_default_range(cls, *args, **kwargs) -> "DefaultValue": ...

class Devicetreecon(Ocontext):
    path: str = ...

class DevicetreeconIterator(OcontextIterator):
    def __next__(self) -> Devicetreecon: ...

class FSUse(Ocontext):
    fs: str = ...
    ruletype: "FSUseRuletype" = ...

class FSUseIterator(OcontextIterator):
    def __next__(self) -> FSUse: ...

class FSUseRuletype(PolicyEnum):
    fs_use_task: int = ...
    fs_use_trans: int = ...
    fs_use_xattr: int = ...

class FileNameTERule(BaseTERule):
    default: "Type" = ...
    filename: str = ...
    perms: NoReturn = ...
    ruletype: "TERuletype" = ...
    source: TypeOrAttr = ...
    tclass: "ObjClass" = ...
    target: TypeOrAttr = ...
    def expand(self, *args, **kwargs) -> Iterable["FileNameTERule"]: ...

class FileNameTERuleIterator(HashtabIterator):
    def __next__(self) -> "FileNameTERule": ...

class GenfsFiletype(int): ...

class Genfscon(Ocontext):
    filetype: "GenfsFiletype" = ...
    fs: str = ...
    path: str = ...
    tclass: "ObjClass" = ...

class GenfsconIterator:
    def __iter__(self) -> Iterable["Genfscon"]: ...
    def __len__(self) -> int: ...
    def __next__(self) -> "Genfscon": ...

class GenfsconOcontextIterator(OcontextIterator):
    def __next__(self) -> "Ocontext": ...

class HandleUnknown(PolicyEnum):
    allow: int = ...
    deny: int = ...
    reject: int = ...

class Ibendportcon(Ocontext):
    name: str = ...
    port: int = ...

class IbendportconIterator(OcontextIterator):
    def __next__(self) -> "Ibendportcon": ...

class Ibpkeycon(Ocontext):
    pkeys: "IbpkeyconRange" = ...
    subnet_prefix: ipaddress.IPv6Address = ...

class IbpkeyconIterator(OcontextIterator):
    def __next__(self) -> "Ibpkeycon": ...

@dataclass
class IbpkeyconRange:
    high: int = ...
    low: int = ...

class InitialSID(Ocontext):
    name: str = ...

class InitialSIDIterator(OcontextIterator):
    def __next__(self) -> "InitialSID": ...

class InvalidBoolean(setools.exception.InvalidSymbol): ...

class InvalidBoundsType(setools.exception.InvalidSymbol): ...

class InvalidCategory(setools.exception.InvalidSymbol): ...

class InvalidClass(setools.exception.InvalidSymbol): ...

class InvalidCommon(setools.exception.InvalidSymbol): ...

class InvalidConstraintType(setools.exception.InvalidSymbol): ...

class InvalidDefaultRange(setools.exception.InvalidSymbol): ...

class InvalidDefaultType(setools.exception.InvalidRuleType): ...

class InvalidDefaultValue(setools.exception.InvalidSymbol): ...

class InvalidFSUseType(setools.exception.InvalidRuleType): ...

class InvalidInitialSid(setools.exception.InvalidSymbol): ...

class InvalidLevel(setools.exception.InvalidSymbol): ...

class InvalidLevelDecl(setools.exception.InvalidSymbol): ...

class InvalidMLSRuleType(setools.exception.InvalidRuleType): ...

class InvalidPolicy(ValueError, setools.exception.PolicyrepException): ...

class InvalidRBACRuleType(setools.exception.InvalidRuleType): ...

class InvalidRange(setools.exception.InvalidSymbol): ...

class InvalidRole(setools.exception.InvalidSymbol): ...

class InvalidRuleType(setools.exception.InvalidSymbol): ...

class InvalidSensitivity(setools.exception.InvalidSymbol): ...

class InvalidTERuleType(setools.exception.InvalidRuleType): ...

class InvalidType(setools.exception.InvalidSymbol): ...

class InvalidUser(setools.exception.InvalidSymbol): ...

class IoctlSet(frozenset[int]):
    def ranges(self) -> int: ...

class Iomemcon(Ocontext):
    addr: "IomemconRange" = ...

class IomemconIterator(OcontextIterator):
    def __next__(self) -> "Iomemcon": ...

@dataclass
class IomemconRange:
    high: int = ...
    low: int = ...

class Ioportcon(Ocontext):
    ports: "IoportconRange" = ...

class IoportconIterator(OcontextIterator):
    def __next__(self) -> Ioportcon: ...

@dataclass
class IoportconRange:
    high: int = ...
    low: int = ...

class Level(BaseMLSLevel):
    def __rxor__(self, other) -> bool: ...
    def __xor__(self, other) -> bool: ...

class LevelDecl(BaseMLSLevel): ...

class LevelDeclHashtabIterator(HashtabIterator):
    def __next__(self) -> "LevelDecl": ...

class LowLevelPolicyError(ValueError, setools.exception.PolicyrepException): ...

class MLSDisabled(setools.exception.PolicyrepException): ...

class MLSRule(PolicyRule):
    default: "Range" = ...
    origin: "MLSRule" = ...
    ruletype: "MLSRuletype" = ...
    source: TypeOrAttr = ...
    tclass: "ObjClass" = ...
    target: TypeOrAttr = ...
    def expand(self) -> Iterable["MLSRule"]: ...

class MLSRuleIterator(HashtabIterator):
    def __next__(self) -> "MLSRule": ...

class MLSRuletype(PolicyEnum):
    range_transition: int = ...

class Netifcon(Ocontext):
    netif: str = ...
    packet: "Context" = ...

class NetifconIterator(OcontextIterator):
    def __next__(self) -> "Netifcon": ...

class NoCommon(AttributeError, setools.exception.PolicyrepException): ...

class NoDefaults(setools.exception.InvalidSymbol): ...

class NoStatement(setools.exception.SymbolUseError): ...

class Nodecon(Ocontext):
    ip_version: "NodeconIPVersion" = ...
    network: ipaddress.IPv4Network | ipaddress.IPv6Network = ...

class NodeconIPVersion(PolicyEnum):
    ipv4: int = ...
    ipv6: int = ...

class NodeconIterator(OcontextIterator):
    def __next__(self) -> "Nodecon": ...

class ObjClass(PolicySymbol):
    common: "Common" = ...
    perms: frozenset[str] = ...
    def constraints(self, *args, **kwargs) -> Iterable["Constraint"]: ...
    def defaults(self, *args, **kwargs) -> Iterable[AnyDefault]: ...
    def validatetrans(self, *args, **kwargs) -> Iterable["Validatetrans"]: ...

class ObjClassHashtabIterator(HashtabIterator):
    def __next__(self) -> "ObjClass": ...

class Pcidevicecon(Ocontext):
    device: str = ...

class PcideviceconIterator(OcontextIterator):
    def __next__(self) -> "Pcidevicecon": ...

class PermissionVectorIterator(PolicyIterator):
    def __next__(self) -> str: ...

class Pirqcon(Ocontext):
    irq: int = ...

class PirqconIterator(OcontextIterator):
    def __next__(self) -> "Pirqcon": ...

class PolicyCapability(PolicySymbol): ...

class PolicyCapabilityIterator(EbitmapIterator):
    def __next__(self) -> "PolicyCapability": ...

class PolicyTarget(PolicyEnum):
    selinux: int = ...
    xen: int = ...

class Portcon(Ocontext):
    ports: "PortconRange" = ...
    protocol: "PortconProtocol" = ...

class PortconIterator(OcontextIterator):
    def __next__(self) -> Portcon: ...

class PortconProtocol(PolicyEnum):
    dccp: int = ...
    sctp: int = ...
    tcp: int = ...
    udp: int = ...

@dataclass
class PortconRange:
    high: int = ...
    low: int = ...

class RBACRuletype(PolicyEnum):
    allow: int = ...
    role_transition: int = ...

class Range(PolicyObject):
    high: Level = ...
    low: Level = ...
    def __contains__(self, other) -> bool: ...

class Role(PolicySymbol):
    dominated_roles: frozenset["Role"] = ...
    def expand(self) -> Iterable["Role"]: ...
    def types(self) -> Iterable["Type"]: ...

class RoleAllow(PolicyRule):
    default: NoReturn = ...
    ruletype: "RBACRuletype" = ...
    source: "Role" = ...
    tclass: NoReturn = ...
    target: "Role" = ...
    def expand(self) -> Iterable["RoleAllow"]: ...

class RoleAllowIterator(PolicyIterator):
    def __next__(self) -> "RoleAllow": ...

class RoleEbitmapIterator(EbitmapIterator):
    def __next__(self) -> "Role": ...

class RoleHashtabIterator(HashtabIterator):
    def __next__(self) -> "Role": ...

class RoleTransition(PolicyRule):
    default: "Role" = ...
    ruletype: "RBACRuletype" = ...
    source: "Role" = ...
    tclass: "ObjClass" = ...
    target: TypeOrAttr = ...
    def expand(self) -> Iterable["RoleTransition"]: ...

class RoleTransitionIterator(PolicyIterator):
    def __next__(self) -> "RoleTransition": ...

class RuleNotConditional(AttributeError, setools.exception.PolicyrepException): ...

class RuleUseError(setools.exception.SymbolUseError): ...

class SELinuxPolicy:
    allow_count: int = ...
    allowxperm_count: int = ...
    auditallow_count: int = ...
    auditallowxperm_count: int = ...
    boolean_count: int = ...
    category_count: int = ...
    class_count: int = ...
    common_count: int = ...
    conditional_count: int = ...
    constraint_count: int = ...
    default_count: int = ...
    devicetreecon_count: int = ...
    dontaudit_count: int = ...
    dontauditxperm_count: int = ...
    fs_use_count: int = ...
    genfscon_count: int = ...
    handle_unknown: "HandleUnknown" = ...
    ibendportcon_count: int = ...
    ibpkeycon_count: int = ...
    initialsids_count: int = ...
    iomemcon_count: int = ...
    ioportcon_count: int = ...
    level_count: int = ...
    mls: bool = ...
    mlsconstraint_count: int = ...
    mlsvalidatetrans_count: int = ...
    netifcon_count: int = ...
    neverallow_count: int = ...
    neverallowxperm_count: int = ...
    nodecon_count: int = ...
    path: str = ...
    pcidevicecon_count: int = ...
    permission_count: int = ...
    permissives_count: int = ...
    pirqcon_count: int = ...
    polcap_count: int = ...
    portcon_count: int = ...
    range_transition_count: int = ...
    role_allow_count: int = ...
    role_count: int = ...
    role_transition_count: int = ...
    target_platform: "PolicyTarget" = ...
    type_attribute_count: int = ...
    type_change_count: int = ...
    type_count: int = ...
    type_member_count: int = ...
    type_transition_count: int = ...
    typebounds_count: int = ...
    user_count: int = ...
    validatetrans_count: int = ...
    version: int = ...
    def __init__(self, policyfile: str | None = None) -> None: ...
    def bools(self) -> Iterable["Boolean"]: ...
    def bounds(self) -> Iterable["Bounds"]: ...
    def categories(self) -> Iterable["Category"]: ...
    def classes(self) -> Iterable["ObjClass"]: ...
    def commons(self) -> Iterable["Common"]: ...
    def conditionals(self) -> Iterable["Conditional"]: ...
    def constraints(self) -> Iterable[AnyConstraint]: ...
    def defaults(self) -> Iterable[AnyDefault]: ...
    def devicetreecons(self) -> Iterable["Devicetreecon"]: ...
    def fs_uses(self) -> Iterable["FSUse"]: ...
    def genfscons(self) -> Iterable["Genfscon"]: ...
    def ibendportcons(self) -> Iterable["Ibendportcon"]: ...
    def ibpkeycons(self) -> Iterable["Ibpkeycon"]: ...
    def initialsids(self) -> Iterable["InitialSID"]: ...
    def iomemcons(self) -> Iterable["Iomemcon"]: ...
    def ioportcons(self) -> Iterable["Ioportcon"]: ...
    def levels(self) -> Iterable["Level"]: ...
    def lookup_boolean(self, name: "Boolean" | str) -> "Boolean": ...
    def lookup_category(self, name: "Category" | str, deref: bool = True) -> "Category": ...
    def lookup_class(self, name: "ObjClass" | str) -> "ObjClass": ...
    def lookup_common(self, name: "Common" | str) -> "Common": ...
    def lookup_initialsid(self, name: "InitialSID" | str) -> "InitialSID": ...
    def lookup_level(self, name: "Level" | str) -> "Level": ...
    def lookup_range(self, name: "Range" | str) -> "Range": ...
    def lookup_role(self, name: "Role" | str) -> Role: ...
    def lookup_sensitivity(self, name: "Sensitivity" | str) -> "Sensitivity": ...
    def lookup_type(self, name: "Type" | str, deref: bool = True) -> "Type": ...
    def lookup_type_or_attr(self, name: TypeOrAttr | str, deref: bool = True) -> TypeOrAttr: ...
    def lookup_typeattr(self, name: "TypeAttribute" | str) -> "TypeAttribute": ...
    def lookup_user(self, name: "User" | str) -> "User": ...
    def mlsrules(self) -> Iterable["MLSRule"]: ...
    def netifcons(self) -> Iterable["Netifcon"]: ...
    def nodecons(self) -> Iterable["Nodecon"]: ...
    def pcidevicecons(self) -> Iterable["Pcidevicecon"]: ...
    def pirqcons(self) -> Iterable["Pirqcon"]: ...
    def polcaps(self) -> Iterable["PolicyCapability"]: ...
    def portcons(self) -> Iterable["Portcon"]: ...
    def rbacrules(self) -> Iterable[AnyRBACRule]: ...
    def roles(self) -> Iterable["Role"]: ...
    def sensitivities(self) -> Iterable["Sensitivity"]: ...
    def terules(self) -> Iterable[AnyTERule]: ...
    def typeattributes(self) -> Iterable["TypeAttribute"]: ...
    def types(self) -> Iterable["Type"]: ...
    def users(self) -> Iterable["User"]: ...
    def __copy__(self) -> "SELinuxPolicy": ...
    def __deepcopy__(self, memo) -> "SELinuxPolicy": ...

class Sensitivity(PolicySymbol):
    def aliases(self, *args, **kwargs) -> Any: ...
    def level_decl(self, *args, **kwargs) -> Any: ...

class SensitivityHashtabIterator(HashtabIterator):
    def __next__(self) -> "Sensitivity": ...

class SymbolUseError(AttributeError, setools.exception.PolicyrepException): ...

class TERule(BaseTERule):
    default: "Type" = ...
    perms: NoReturn = ...
    def expand(self) -> Iterable["TERule"]: ...

class TERuleIterator(PolicyIterator):
    def __next__(self) -> "TERule": ...

class TERuleNoFilename(AttributeError, setools.exception.PolicyrepException): ...

class TERuletype(PolicyEnum):
    allow: int = ...
    allowxperm: int = ...
    auditallow: int = ...
    auditallowxperm: int = ...
    dontaudit: int = ...
    dontauditxperm: int = ...
    neverallow: int = ...
    neverallowxperm: int = ...
    type_change: int = ...
    type_member: int = ...
    type_transition: int = ...

@dataclass
class TruthTableRow:
    values: dict[str, bool]
    result: bool

class Type(BaseType):
    ispermissive: bool = ...
    def aliases(self) -> Iterable[str]: ...
    def attributes(self) -> Iterable["TypeAttribute"]: ...
    def expand(self) -> Iterable["Type"]: ...

class TypeAttribute(BaseType):
    ispermissive: bool = ...
    def aliases(self) -> Iterable[str]: ...
    def attributes(self) -> Iterable["TypeAttribute"]: ...
    def expand(self) -> Iterable["Type"]: ...
    def __iter__(self) -> Iterable["TypeAttribute"]: ...
    def __len__(self) -> int: ...

class TypeAttributeEbitmapIterator(EbitmapIterator):
    def __next__(self) -> "TypeAttribute": ...

class TypeAttributeHashtabIterator(HashtabIterator):
    def __next__(self) -> "TypeAttribute": ...

class TypeEbitmapIterator(EbitmapIterator):
    def __next__(self) -> "Type": ...

class TypeHashtabIterator(HashtabIterator):
    def __next__(self) -> "Type": ...

class TypeOrAttributeEbitmapIterator(EbitmapIterator):
    def __next__(self) -> TypeOrAttr: ...

class TypeboundsIterator(HashtabIterator):
    def __next__(self) -> "Bounds": ...

class User(PolicySymbol):
    mls_level: "Level" = ...
    mls_range: "Range" = ...
    roles: frozenset["Role"] = ...

class UserEbitmapIterator(EbitmapIterator):
    def __next__(self) -> "User": ...

class UserHashtabIterator(HashtabIterator):
    def __next__(self) -> "User": ...

class Validatetrans(BaseConstraint):
    perms: NoReturn = ...

class ValidatetransIterator(PolicyIterator):
    def __next__(self) -> "Validatetrans": ...

class WeakKeyDefaultDict(weakref.WeakKeyDictionary): ...
